From 96d6a577160ae7c23a460c192344c72446214c5b Mon Sep 17 00:00:00 2001
From: "sungmok.shin" <sungmok.shin@lge.com>
Date: Wed, 15 Jul 2020 15:08:14 +0900
Subject: [PATCH] Adds noexec option for fork and spawn APIs of nodejs

:Release Notes:
Adds noexec option, which disables exec() syscall of
fork and spawn APIs of nodejs.

:Detailed Notes:
Initial Andrii Motsok`s patch:
https://gpro.lgsvl.com/#/c/54912/
sergii.nikolaiev@lge.com: fixed crashes in child process after fork
alexander.pryadka@lge.com: code refactoring. Added noexec option.

:Testing Performed:
Tested using fork server and patches:
https://g2g.lgsvl.com/#/c/7712
https://g2g.lgsvl.com/#/c/7881/
https://g2g.lgsvl.com/#/c/7883/
https://g2g.lgsvl.com/#/c/7884/
https://g2g.lgsvl.com/#/c/7885/
executing example helloworld, activityexample and some other
dynamic system services.

:QA Notes:

:Issues Addressed:
[DRD-4340] Using fork for loading new node instance

Change-Id: I66437f45c8134a0094ea2836e39ef9162ca0c058
---
 deps/uv/include/uv.h          |  7 +++++-
 deps/uv/src/unix/process.c    | 46 +++++++++++++++++++++++++++++++----
 lib/internal/child_process.js |  4 +++
 src/env.h                     |  3 ++-
 src/process_wrap.cc           |  6 +++++
 5 files changed, 59 insertions(+), 7 deletions(-)

diff --git a/deps/uv/include/uv.h b/deps/uv/include/uv.h
index 54048ab3..10976f82 100644
--- a/deps/uv/include/uv.h
+++ b/deps/uv/include/uv.h
@@ -1018,7 +1018,12 @@ enum uv_process_flags {
    * option is only meaningful on Windows systems. On Unix it is silently
    * ignored.
    */
-  UV_PROCESS_WINDOWS_HIDE_GUI = (1 << 6)
+  UV_PROCESS_WINDOWS_HIDE_GUI = (1 << 6),
+  /*
+   * Fork new process without exec system call. This option is only meaningful
+   * on Linux systems.
+   */
+  UV_PROCESS_NO_EXEC = (1 << 7)
 };
 
 /*
diff --git a/deps/uv/src/unix/process.c b/deps/uv/src/unix/process.c
index bb6b76c9..68b039d4 100644
--- a/deps/uv/src/unix/process.c
+++ b/deps/uv/src/unix/process.c
@@ -373,7 +373,29 @@ static void uv__process_child_init(const uv_process_options_t* options,
   }
 
   if (options->env != NULL) {
-    environ = options->env;
+    if (options->flags & UV_PROCESS_NO_EXEC) {
+      char **env_copy;
+      int envc = 0;
+      while (options->env[envc] != NULL) {
+        ++envc;
+      }
+      env_copy = (char**)malloc(sizeof(char*) * (envc + 1));
+      if (env_copy != NULL) {
+        int i = 0;
+        for (; i < envc; ++i) {
+          env_copy[i] = strdup(options->env[i]);
+          if (env_copy[i] == NULL) {
+            abort();
+          }
+        }
+        env_copy[envc] = NULL;
+        environ = env_copy;
+      } else {
+        abort();
+      }
+    } else {
+      environ = options->env;
+    }
   }
 
   /* Reset signal disposition.  Use a hard-coded limit because NSIG
@@ -406,9 +428,11 @@ static void uv__process_child_init(const uv_process_options_t* options,
     _exit(127);
   }
 
-  execvp(options->file, options->args);
-  uv__write_int(error_fd, UV__ERR(errno));
-  _exit(127);
+  if (!(options->flags & UV_PROCESS_NO_EXEC)) {
+    execvp(options->file, options->args);
+    uv__write_int(error_fd, UV__ERR(errno));
+    _exit(127);
+  }
 }
 #endif
 
@@ -438,7 +462,8 @@ int uv_spawn(uv_loop_t* loop,
                               UV_PROCESS_WINDOWS_HIDE |
                               UV_PROCESS_WINDOWS_HIDE_CONSOLE |
                               UV_PROCESS_WINDOWS_HIDE_GUI |
-                              UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS)));
+                              UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS |
+                              UV_PROCESS_NO_EXEC)));
 
   uv__handle_init(loop, (uv_handle_t*)process, UV_PROCESS);
   QUEUE_INIT(&process->queue);
@@ -506,6 +531,17 @@ int uv_spawn(uv_loop_t* loop,
 
   if (pid == 0) {
     uv__process_child_init(options, stdio_count, pipes, signal_pipe[1]);
+    if (options->flags & UV_PROCESS_NO_EXEC) {
+      /* Release lock in child process */
+      uv_rwlock_wrunlock(&loop->cloexec_lock);
+      uv__close(signal_pipe[0]);
+      uv__close(signal_pipe[1]);
+
+      process->pid = pid;
+
+      free(pipes);
+      return 0;
+    }
     abort();
   }
 
diff --git a/lib/internal/child_process.js b/lib/internal/child_process.js
index 9872edca..3d48ac4c 100644
--- a/lib/internal/child_process.js
+++ b/lib/internal/child_process.js
@@ -396,6 +396,10 @@ ChildProcess.prototype.spawn = function(options) {
 
   this.pid = this._handle.pid;
 
+  if (this.pid == 0) {
+    return 0;
+  }
+
   for (i = 0; i < stdio.length; i++) {
     const stream = stdio[i];
     if (stream.type === 'ignore') continue;
diff --git a/src/env.h b/src/env.h
index 60cb1b6d..43bd2a11 100644
--- a/src/env.h
+++ b/src/env.h
@@ -376,7 +376,8 @@ constexpr size_t kFsStatsBufferLength =
   V(write_host_object_string, "_writeHostObject")                              \
   V(write_queue_size_string, "writeQueueSize")                                 \
   V(x_forwarded_string, "x-forwarded-for")                                     \
-  V(zero_return_string, "ZERO_RETURN")
+  V(zero_return_string, "ZERO_RETURN")                                         \
+  V(noexec_string, "noexec")                                                   \
 
 #define ENVIRONMENT_STRONG_PERSISTENT_TEMPLATES(V)                             \
   V(as_callback_data_template, v8::FunctionTemplate)                           \
diff --git a/src/process_wrap.cc b/src/process_wrap.cc
index a75f271d..74634928 100644
--- a/src/process_wrap.cc
+++ b/src/process_wrap.cc
@@ -181,6 +181,12 @@ class ProcessWrap : public HandleWrap {
     node::Utf8Value file(env->isolate(), file_v);
     options.file = *file;
 
+    // options.noexec
+    Local<String> noexec_key = env->noexec_string();
+    if (js_options->Get(noexec_key)->IsTrue()) {
+        options.flags |= UV_PROCESS_NO_EXEC;
+    }
+
     // options.args
     Local<Value> argv_v =
         js_options->Get(context, env->args_string()).ToLocalChecked();
-- 
2.17.1

