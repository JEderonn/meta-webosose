From ccb4ed6801eed819e7d182b086eb984c4554f2ba Mon Sep 17 00:00:00 2001
From: YoungSun Park <cathy.park@lge.com>
Date: Fri, 16 Aug 2019 21:32:22 +0900
Subject: [PATCH] QQuickWindow: Consider z-order of children when delivering
 pointer events

When creating a target item list for handling pointer events, put
children after the parent item if they have negative z-order value.
This fixes an issue where an item does not receive a pointer event if
there is a child item that accepts the event even when that child item
is shown under the parent item as per the stacking order.

Change-Id: I711faa22516f5c2396b1138dc507bcaa4ba22241
Upstream-Status: Submitted [https://codereview.qt-project.org/c/qt/qtdeclarative/+/288660]
---
 src/quick/items/qquickwindow.cpp | 36 +++++++++++++++++++-------------
 1 file changed, 22 insertions(+), 14 deletions(-)

diff --git a/src/quick/items/qquickwindow.cpp b/src/quick/items/qquickwindow.cpp
index cc4991984d..b2534fe0b0 100644
--- a/src/quick/items/qquickwindow.cpp
+++ b/src/quick/items/qquickwindow.cpp
@@ -2390,23 +2390,13 @@ QVector<QQuickItem *> QQuickWindowPrivate::pointerTargets(QQuickItem *item, QQui
     QVector<QQuickItem *> targets;
     auto itemPrivate = QQuickItemPrivate::get(item);
     QPointF itemPos = item->mapFromScene(point->scenePosition());
+    bool relevant = item->contains(itemPos);
     // if the item clips, we can potentially return early
     if (itemPrivate->flags & QQuickItem::ItemClipsChildrenToShape) {
-        if (!item->contains(itemPos))
+        if (!relevant)
             return targets;
     }
 
-    // recurse for children
-    QList<QQuickItem *> children = itemPrivate->paintOrderChildItems();
-    for (int ii = children.count() - 1; ii >= 0; --ii) {
-        QQuickItem *child = children.at(ii);
-        auto childPrivate = QQuickItemPrivate::get(child);
-        if (!child->isVisible() || !child->isEnabled() || childPrivate->culled)
-            continue;
-        targets << pointerTargets(child, point, checkMouseButtons, checkAcceptsTouch);
-    }
-
-    bool relevant = item->contains(itemPos);
     if (itemPrivate->hasPointerHandlers()) {
         if (!relevant)
             if (itemPrivate->anyPointerHandlerWants(point))
@@ -2417,8 +2407,26 @@ QVector<QQuickItem *> QQuickWindowPrivate::pointerTargets(QQuickItem *item, QQui
         if (relevant && checkAcceptsTouch && !(item->acceptTouchEvents() || item->acceptedMouseButtons()))
             relevant = false;
     }
-    if (relevant)
-        targets << item; // add this item last: children take precedence
+
+    QList<QQuickItem *> children = itemPrivate->paintOrderChildItems();
+    if (relevant) {
+        auto it = std::lower_bound(children.begin(), children.end(), 0,
+           [](auto lhs, auto rhs) -> bool { return lhs->z() < rhs; });
+        children.insert(it, item);
+    }
+
+    for (int ii = children.count() - 1; ii >= 0; --ii) {
+        QQuickItem *child = children.at(ii);
+        auto childPrivate = QQuickItemPrivate::get(child);
+        if (!child->isVisible() || !child->isEnabled() || childPrivate->culled)
+            continue;
+
+        if (child != item)
+            targets << pointerTargets(child, point, checkMouseButtons, checkAcceptsTouch);
+        else
+            targets << child;
+    }
+
     return targets;
 }
 
